## CPU虚拟化

虽然只有少量的物理CPU，但是操作系统要模拟出无数个CPU，好像每个进程都有CPU,利用时分共享技术实现CPU虚拟化。

## 进程的基本构成

* 进程是正在运行程序的抽象，是一个正在运行的程序。
* 进程包括：内存【指令、数据】、寄存器、文件描述符

## 进程创建

* 将代码和所有静态数据加载到内存中，加载到进程的地址空间中。
* 给运行时栈分配内存和堆分配内存
* 执行其他初始化任务，特别是I/O相关，创建三个打开的文件描述符
* 跳转到main函数

## 进程的状态

初始、运行、就绪、阻塞、僵死【已退出但是尚未清理的状态，等待其他进程收尸】
Linux上进程的五种状态：

1. R——Runnable（运行）：正在运行或在运行队列中等待

2. S——sleeping（中断）：休眠中，受阻，在等待某个条件的形成或接收到信号

3. D——uninterruptible sleep(不可中断)：收到信号不唤醒和不可运行，进程必须等待直到有中断发生

4. Z——zombie（僵死）：进程已终止，但进程描述还在，直到父进程调用wait4()系统调用后释放

5. T——traced or stoppd(停止)：进程收到SiGSTOP,SIGSTP,SIGTOU信号后停止运行

## 进程的地址空间

* 进程的地址空间及其寄存器上下文，反映了进程所运行程序的当前状态。
* 进程的地址空间由若干不同的段组成，每个段是一片连续存储单元，分别用于存放程序的代码、初始数据、静态变量，以及用作栈或堆的空间。
    * 正文段：存放程序的执行代码。它是只读共享段，即在存储器内只保存一个副本而允许多个程序执行该副本。
    * 初始化数据段：也简称为数据段，用于存放程序中赋予了初值的静态变量和全局变量。
    * 未初始化数据段：也称为bss段，这个段的数据在程序运行之前可由内核置为0。C程序中所有不带初值的全局变量和静态局部变量均存放在此段中。
    * 栈：用于存放函数内的局部变量、临时变量以及函数的调用环境，如函数的返回地址、函数的栈帧指针、函数入口参数等。C程序中的自动变量均存放在栈中。
    * 堆：用于动态申请的存储空间。


## fork调用

* 调用fork()派生一个进程为复制一个进程映像。fork()调用成功时，父、子进程分别以不同的返回值从fork()返回：子进程的返回值为0，父进程的返回值是新创建的这个子进程的PID，子进程可通过调用getppid()获得其父进程的PID。

* fork()创建子进程时继承了父进程的数据段、代码段、栈段、堆，注意从父进程继承来的是虚拟地址空间，同时也复制了页表（没有复制物理块）。

* 当fork()创建进程后，子进程与父进程的执行顺序是不确定的，它们之中究竟谁先执行取决于内核的调度算法。

* 写时复制：父进程的数据和栈空间临时成为只读的并标志为“写复制”。子进程一开始与父进程共享存储页。如果子进程或父进程企图修改某页，缺页中断便出现（因为页是只读的），从而UNIX内核识别出这是一个“写-复制”页，于是复制该页成为新的可写页。这样，便只有那些修改了的页才需复制，而不是复制整个进程的地址空间。

## wait调用

* 等待进程完成：当父进程用fork()派生一个新进程后，它便可以自由地进行自己的工作，父、子进程可以同时处于执行，相互之间没有等待的情况。不过这种情况并不总是人们所希望的，父进程常常会需要等待子进程执行完后才能继续执行。wait()首先检查调用进程是否有任何已经终止了的子进程，如果有的话，它立即返回。如果没有已终止的子进程，wait()阻塞调用进程直至有一个子进程终止并在此时立即返回。

## exec调用

* 当用fork()创建一个新进程时，它所创建的子进程具有父进程的程序映像，子进程是父进程的克隆。但在多数情况下，创建新进程的目的是为了执行一个新程序，因此，子进程从父进程克隆的程序映像将以某种方式被新程序文件的程序映像所替代。exec()用新程序的地址空间覆盖当前程序的地址空间时，它只覆盖正文段、数据段和栈段，原进程的几乎所有内部执行环境仍保持不变。

## 终止进程

* 进程有两种终止方式，一种为正常终止，另一种为异常终止。正常终止由main()返回，或直接调用exit()或_exit()而终止，一般使用exit。异常终止通过调用abort()或由于信号终止。
    * exit()以出口状态status终止进程，该函数不返回。调用exit()将引起下述动作：
        * 按atexit()注册时相反的顺序调用所有注册函数。
        * 关闭所有打开的流。这将导致写出所有被缓冲的输出【用户进程缓冲区到内核缓存区】。
        * 删除用tmpfile()建立的所有临时文件。
        * 调用_exit(status)终止进程，直接使进程停止运行，清除其使用的内存空间，并清除其在内核的各种数据结构。
    * 调用abort()将立即终止程序的执行，它不执行用atexit()注册的清理函数，但在终止程序之前关闭所有打开的流并生成一个core文件。所有异常终止程序的原因都是由信号造成的。实际上，abort()通过生成一个SIGABRT信号来流产程序。

##僵尸进程与孤儿进程

* 僵尸进程【死尸】
    * 首先内核会释放终止进程(调用了exit系统调用)所使用的所有存储区，关闭所有打开的文件等，但内核为每一个终止子进程保存了一定量的信息。这些信息至少包括进程ID，进程的终止状态，以及该进程使用的CPU时间，所以当终止子进程的父进程调用wait或waitpid时就可以得到这些信息。
    * 僵尸进程就是指：一个进程执行了exit系统调用退出，而其父进程并没有为它收尸(调用wait或waitpid来获得它的结束状态)的进程。任何一个子进程(init除外)在exit后并非马上就消失，而是留下一个称外僵尸进程的数据结构，等待父进程处理。这是每个子进程都必需经历的阶段。另外子进程退出的时候会向其父进程发送一个SIGCHLD信号。
    * 设置僵死状态的目的是维护子进程的信息，以便父进程在以后某个时候获取。

* 孤儿进程：孤儿进程指的是在其父进程执行完成或被终止后仍继续运行的一类进程。这些孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。
 Note:线程是一个具有自己的栈空间、局部变量以及程序计数器，与同一地址空间内其他线程共享进程资源的执行流。 
```
    PID为0的进程是调度进程，磁盘上没有程序与之对应——它是内核的一部分，称为系统进程。
    PID为1的进程是init进程，它在内核自举之后负责系统的建立工作，是一个具有超级用户特权的用户进程。
        我们可以将init进程视作操作系统中的进程管理器，它是所有其他进程的祖先。
```